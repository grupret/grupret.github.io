<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feast Feature Store: Production ML Feature Management | Gurpreet Gandhi</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        .feast-visualization {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
            color: white;
            position: relative;
            overflow: hidden;
        }
        
        .feast-visualization::before {
            content: '';
            position: absolute;
            top: -30%;
            right: -30%;
            width: 150%;
            height: 150%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: feast-flow 10s ease-in-out infinite;
        }
        
        @keyframes feast-flow {
            0%, 100% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
        }
        
        .feature-component {
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            position: relative;
        }
        
        .feature-component::after {
            content: '‚ö°';
            position: absolute;
            right: 20px;
            top: 20px;
            font-size: 1.5em;
            opacity: 0.7;
        }
        
        .feature-component:hover {
            transform: translateX(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .architecture-diagram {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }
        
        .arch-component {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            border-top: 4px solid #667eea;
            transition: all 0.3s ease;
        }
        
        .arch-component:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .feature-pipeline {
            background: #fff;
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
        }
        
        .pipeline-step {
            display: flex;
            align-items: center;
            padding: 20px 0;
            border-bottom: 1px solid #e9ecef;
            position: relative;
        }
        
        .pipeline-step:last-child {
            border-bottom: none;
        }
        
        .pipeline-step::after {
            content: '‚Üí';
            position: absolute;
            right: -15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5em;
            color: #667eea;
            font-weight: bold;
        }
        
        .pipeline-step:last-child::after {
            display: none;
        }
        
        .step-icon {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            margin-right: 20px;
            flex-shrink: 0;
        }
        
        .step-content {
            flex: 1;
        }
        
        .performance-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .stat-card:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.3);
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 10px;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .code-demo {
            background: #fff;
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
        }
        
        .demo-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .demo-tab {
            background: #f8f9fa;
            border: none;
            padding: 12px 20px;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .demo-tab.active {
            background: #667eea;
            color: white;
        }
        
        .demo-tab:hover:not(.active) {
            background: #e9ecef;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }
        
        .comparison-card {
            background: #fff;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            border-top: 4px solid #667eea;
            transition: all 0.3s ease;
        }
        
        .comparison-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <span class="logo-text">Gurpreet Gandhi</span>
                <span class="logo-title">Software Architect</span>
            </div>
            <div class="nav-menu">
                <a href="../index.html" class="nav-link">‚Üê Back to Portfolio</a>
                <a href="../projects/neurosymbolic.html" class="nav-link">‚Üê Back to Project</a>
                <a href="../index.html#contact" class="nav-link">Contact</a>
            </div>
        </div>
    </nav>

    <!-- Blog Hero -->
    <section class="blog-hero">
        <div class="container">
            <div class="blog-header">
                <h1 class="blog-title">Feast Feature Store</h1>
                <p class="blog-subtitle">Production-Ready Feature Management for Machine Learning</p>
                <div class="blog-meta">
                    <span class="blog-date"><i class="fas fa-calendar"></i> January 2025</span>
                    <span class="blog-readtime"><i class="fas fa-clock"></i> 24 min read</span>
                    <span class="blog-category"><i class="fas fa-tag"></i> MLOps</span>
                </div>
            </div>
        </div>
    </section>

    <!-- Blog Content -->
    <section class="blog-content">
        <div class="container">
            <article class="blog-article">
                <div class="article-content">
                    <h2>Introduction to Feature Stores</h2>
                    <p>
                        Feature stores have emerged as a critical component in the modern ML infrastructure stack, 
                        addressing the challenges of feature management, consistency, and reusability across 
                        training and serving environments. Feast (Feature Store) is an open-source feature store 
                        that provides a unified interface for feature definition, storage, and serving, enabling 
                        teams to build reliable and scalable ML systems.
                    </p>

                    <div class="feast-visualization">
                        <h3><i class="fas fa-database"></i> Feast Architecture Overview</h3>
                        <div class="feature-component">
                            <h4>üìä Feature Registry</h4>
                            <p>Centralized catalog of feature definitions and metadata</p>
                        </div>
                        <div class="feature-component">
                            <h4>üè™ Offline Store</h4>
                            <p>Historical feature storage for training and batch inference</p>
                        </div>
                        <div class="feature-component">
                            <h4>‚ö° Online Store</h4>
                            <p>Low-latency feature serving for real-time predictions</p>
                        </div>
                        <div class="feature-component">
                            <h4>üîÑ Feature Server</h4>
                            <p>HTTP/gRPC API for feature retrieval and serving</p>
                        </div>
                    </div>

                    <h2>Core Components and Architecture</h2>

                    <div class="architecture-diagram">
                        <div class="arch-component">
                            <h3><i class="fas fa-book"></i> Feature Registry</h3>
                            <p>
                                The feature registry serves as the central catalog for all feature definitions, 
                                storing metadata about features, their schemas, data sources, and transformation logic. 
                                It provides version control and lineage tracking for features.
                            </p>
                            <ul>
                                <li>Feature schema definitions</li>
                                <li>Data source configurations</li>
                                <li>Transformation specifications</li>
                                <li>Feature versioning and lineage</li>
                            </ul>
                        </div>
                        
                        <div class="arch-component">
                            <h3><i class="fas fa-archive"></i> Offline Store</h3>
                            <p>
                                The offline store manages historical feature data for training and batch inference. 
                                It supports various storage backends including data warehouses, data lakes, and 
                                file systems, optimized for analytical workloads.
                            </p>
                            <ul>
                                <li>BigQuery, Snowflake, Redshift</li>
                                <li>Parquet files on S3/GCS</li>
                                <li>Point-in-time correctness</li>
                                <li>Time travel capabilities</li>
                            </ul>
                        </div>
                        
                        <div class="arch-component">
                            <h3><i class="fas fa-bolt"></i> Online Store</h3>
                            <p>
                                The online store provides low-latency access to the latest feature values for 
                                real-time inference. It's optimized for high-throughput, low-latency reads 
                                with support for various key-value stores.
                            </p>
                            <ul>
                                <li>Redis, DynamoDB, Firestore</li>
                                <li>Sub-millisecond latency</li>
                                <li>High availability and scalability</li>
                                <li>Automatic feature materialization</li>
                            </ul>
                        </div>
                        
                        <div class="arch-component">
                            <h3><i class="fas fa-server"></i> Feature Server</h3>
                            <p>
                                The feature server exposes features through HTTP and gRPC APIs, handling 
                                authentication, authorization, and request routing. It provides a unified 
                                interface for feature retrieval across different environments.
                            </p>
                            <ul>
                                <li>REST and gRPC endpoints</li>
                                <li>Authentication and authorization</li>
                                <li>Request batching and caching</li>
                                <li>Monitoring and observability</li>
                            </ul>
                        </div>
                    </div>

                    <h2>Feature Pipeline Implementation</h2>

                    <div class="feature-pipeline">
                        <h3>End-to-End Feature Pipeline</h3>
                        <div class="pipeline-step">
                            <div class="step-icon">
                                <i class="fas fa-database"></i>
                            </div>
                            <div class="step-content">
                                <h4>Data Ingestion</h4>
                                <p>Raw data ingestion from various sources (databases, streams, files)</p>
                            </div>
                        </div>
                        <div class="pipeline-step">
                            <div class="step-icon">
                                <i class="fas fa-cogs"></i>
                            </div>
                            <div class="step-content">
                                <h4>Feature Engineering</h4>
                                <p>Transform raw data into meaningful features using Feast transformations</p>
                            </div>
                        </div>
                        <div class="pipeline-step">
                            <div class="step-icon">
                                <i class="fas fa-check-circle"></i>
                            </div>
                            <div class="step-content">
                                <h4>Feature Validation</h4>
                                <p>Validate feature quality, schema compliance, and data drift detection</p>
                            </div>
                        </div>
                        <div class="pipeline-step">
                            <div class="step-icon">
                                <i class="fas fa-save"></i>
                            </div>
                            <div class="step-content">
                                <h4>Feature Storage</h4>
                                <p>Store features in offline store for training and online store for serving</p>
                            </div>
                        </div>
                        <div class="pipeline-step">
                            <div class="step-icon">
                                <i class="fas fa-rocket"></i>
                            </div>
                            <div class="step-content">
                                <h4>Feature Serving</h4>
                                <p>Serve features to ML models for training and real-time inference</p>
                            </div>
                        </div>
                    </div>

                    <h2>Implementation Examples</h2>

                    <div class="code-demo">
                        <div class="demo-tabs">
                            <button class="demo-tab active" onclick="showDemo('setup')">Setup & Configuration</button>
                            <button class="demo-tab" onclick="showDemo('features')">Feature Definitions</button>
                            <button class="demo-tab" onclick="showDemo('serving')">Feature Serving</button>
                        </div>

                        <div id="setup-demo" class="demo-content">
                            <h3>Feast Setup and Configuration</h3>
                            <div class="code-block">
                                <pre><code class="language-python">
# feast_config.py - Feast repository configuration
from feast import FeatureStore, Entity, FeatureView, Field
from feast.types import Float32, Int64, String
from feast.data_source import BigQuerySource
from datetime import timedelta

# Initialize Feast store
store = FeatureStore(repo_path=".")

# Define entities
user_entity = Entity(
    name="user_id",
    description="User identifier",
    value_type=String
)

product_entity = Entity(
    name="product_id", 
    description="Product identifier",
    value_type=String
)

# Configure data sources
user_features_source = BigQuerySource(
    name="user_features_source",
    query="""
        SELECT 
            user_id,
            age,
            income,
            signup_days_ago,
            total_purchases,
            avg_purchase_amount,
            event_timestamp
        FROM `project.dataset.user_features`
    """,
    timestamp_field="event_timestamp"
)

product_features_source = BigQuerySource(
    name="product_features_source", 
    query="""
        SELECT
            product_id,
            category,
            price,
            rating,
            review_count,
            days_since_launch,
            event_timestamp
        FROM `project.dataset.product_features`
    """,
    timestamp_field="event_timestamp"
)

# Define feature views
user_features_view = FeatureView(
    name="user_features",
    entities=[user_entity],
    ttl=timedelta(days=30),
    schema=[
        Field(name="age", dtype=Int64),
        Field(name="income", dtype=Float32),
        Field(name="signup_days_ago", dtype=Int64),
        Field(name="total_purchases", dtype=Int64),
        Field(name="avg_purchase_amount", dtype=Float32),
    ],
    source=user_features_source,
    tags={"team": "ml-platform", "domain": "user"}
)

product_features_view = FeatureView(
    name="product_features",
    entities=[product_entity],
    ttl=timedelta(days=7),
    schema=[
        Field(name="category", dtype=String),
        Field(name="price", dtype=Float32),
        Field(name="rating", dtype=Float32),
        Field(name="review_count", dtype=Int64),
        Field(name="days_since_launch", dtype=Int64),
    ],
    source=product_features_source,
    tags={"team": "ml-platform", "domain": "product"}
)

# Apply configuration to Feast
if __name__ == "__main__":
    store.apply([user_entity, product_entity, user_features_view, product_features_view])
    print("Feast configuration applied successfully!")
                                </code></pre>
                            </div>
                        </div>

                        <div id="features-demo" class="demo-content" style="display: none;">
                            <h3>Advanced Feature Definitions</h3>
                            <div class="code-block">
                                <pre><code class="language-python">
# advanced_features.py - Complex feature engineering with Feast
from feast import FeatureView, Field, RequestSource
from feast.types import Float32, Int64, String, Array
from feast.data_source import PushSource
from feast.on_demand_feature_view import on_demand_feature_view
from feast.feature_logging import LoggingConfig
import pandas as pd

# Real-time feature transformations
@on_demand_feature_view(
    sources={
        "user_features": user_features_view,
        "product_features": product_features_view,
        "request_data": RequestSource(
            name="request_data",
            schema=[
                Field(name="current_time", dtype=String),
                Field(name="session_duration", dtype=Int64),
            ]
        )
    },
    schema=[
        Field(name="user_product_affinity", dtype=Float32),
        Field(name="price_sensitivity", dtype=Float32),
        Field(name="purchase_urgency", dtype=Float32),
        Field(name="recommendation_score", dtype=Float32),
    ]
)
def user_product_features(inputs: pd.DataFrame) -> pd.DataFrame:
    """
    On-demand feature transformations for personalized recommendations
    """
    df = pd.DataFrame()
    
    # Calculate user-product affinity based on category preferences
    category_weights = {
        'electronics': 1.2,
        'books': 0.8,
        'clothing': 1.0,
        'home': 0.9
    }
    
    df['user_product_affinity'] = inputs['product_features__category'].map(
        category_weights
    ).fillna(1.0) * (inputs['user_features__total_purchases'] / 10.0)
    
    # Price sensitivity based on income and product price
    df['price_sensitivity'] = (
        inputs['product_features__price'] / 
        (inputs['user_features__income'] / 1000.0)
    ).clip(0, 5)
    
    # Purchase urgency based on session duration and product rating
    df['purchase_urgency'] = (
        inputs['request_data__session_duration'] / 60.0 *
        inputs['product_features__rating'] / 5.0
    ).clip(0, 1)
    
    # Final recommendation score
    df['recommendation_score'] = (
        df['user_product_affinity'] * 0.4 +
        (5 - df['price_sensitivity']) * 0.3 +
        df['purchase_urgency'] * 0.3
    )
    
    return df

# Stream feature view for real-time data
stream_source = PushSource(
    name="user_activity_stream",
    batch_source=None  # No batch source for streaming-only features
)

user_activity_features = FeatureView(
    name="user_activity_features",
    entities=[user_entity],
    ttl=timedelta(minutes=30),  # Short TTL for real-time features
    schema=[
        Field(name="page_views_last_hour", dtype=Int64),
        Field(name="clicks_last_hour", dtype=Int64),
        Field(name="time_on_site_minutes", dtype=Float32),
        Field(name="current_cart_value", dtype=Float32),
        Field(name="items_in_cart", dtype=Int64),
    ],
    source=stream_source,
    tags={"team": "ml-platform", "domain": "realtime"}
)

# Feature view with aggregations
from feast.aggregation import Aggregation, Sum, Count, Avg

user_transaction_features = FeatureView(
    name="user_transaction_features",
    entities=[user_entity],
    ttl=timedelta(days=90),
    schema=[
        Field(name="total_spent_7d", dtype=Float32),
        Field(name="total_spent_30d", dtype=Float32),
        Field(name="transaction_count_7d", dtype=Int64),
        Field(name="transaction_count_30d", dtype=Int64),
        Field(name="avg_transaction_7d", dtype=Float32),
        Field(name="avg_transaction_30d", dtype=Float32),
    ],
    source=BigQuerySource(
        name="user_transactions",
        query="""
            SELECT 
                user_id,
                transaction_amount,
                event_timestamp
            FROM `project.dataset.transactions`
        """,
        timestamp_field="event_timestamp"
    ),
    aggregations=[
        Aggregation(
            column="transaction_amount",
            function=Sum(),
            time_window=timedelta(days=7),
            feature_name="total_spent_7d"
        ),
        Aggregation(
            column="transaction_amount", 
            function=Sum(),
            time_window=timedelta(days=30),
            feature_name="total_spent_30d"
        ),
        Aggregation(
            column="transaction_amount",
            function=Count(),
            time_window=timedelta(days=7),
            feature_name="transaction_count_7d"
        ),
        Aggregation(
            column="transaction_amount",
            function=Count(), 
            time_window=timedelta(days=30),
            feature_name="transaction_count_30d"
        ),
        Aggregation(
            column="transaction_amount",
            function=Avg(),
            time_window=timedelta(days=7),
            feature_name="avg_transaction_7d"
        ),
        Aggregation(
            column="transaction_amount",
            function=Avg(),
            time_window=timedelta(days=30),
            feature_name="avg_transaction_30d"
        ),
    ],
    tags={"team": "ml-platform", "domain": "transactions"}
)
                                </code></pre>
                            </div>
                        </div>

                        <div id="serving-demo" class="demo-content" style="display: none;">
                            <h3>Feature Serving and Retrieval</h3>
                            <div class="code-block">
                                <pre><code class="language-python">
# feature_serving.py - Production feature serving patterns
from feast import FeatureStore
from feast.serving import get_feature_server
import pandas as pd
import asyncio
from typing import List, Dict, Any
import logging

class ProductionFeatureService:
    """
    Production-ready feature serving service with caching and monitoring
    """
    
    def __init__(self, repo_path: str = "."):
        self.store = FeatureStore(repo_path=repo_path)
        self.logger = logging.getLogger(__name__)
        
    def get_online_features(self, entity_rows: List[Dict[str, Any]], 
                          features: List[str]) -> pd.DataFrame:
        """
        Retrieve online features for real-time inference
        """
        try:
            # Get features from online store
            feature_vector = self.store.get_online_features(
                features=features,
                entity_rows=entity_rows
            )
            
            # Convert to DataFrame for easier handling
            df = feature_vector.to_df()
            
            # Log feature retrieval metrics
            self.logger.info(f"Retrieved {len(df)} feature vectors with {len(features)} features")
            
            return df
            
        except Exception as e:
            self.logger.error(f"Error retrieving online features: {e}")
            raise
    
    def get_historical_features(self, entity_df: pd.DataFrame, 
                              features: List[str]) -> pd.DataFrame:
        """
        Retrieve historical features for training
        """
        try:
            # Get historical features with point-in-time correctness
            training_df = self.store.get_historical_features(
                entity_df=entity_df,
                features=features
            ).to_df()
            
            self.logger.info(f"Retrieved historical features for {len(training_df)} entities")
            
            return training_df
            
        except Exception as e:
            self.logger.error(f"Error retrieving historical features: {e}")
            raise
    
    async def batch_get_online_features(self, batch_requests: List[Dict], 
                                      batch_size: int = 100) -> List[pd.DataFrame]:
        """
        Efficiently handle batch feature requests
        """
        results = []
        
        for i in range(0, len(batch_requests), batch_size):
            batch = batch_requests[i:i + batch_size]
            
            # Process batch
            batch_entity_rows = []
            batch_features = set()
            
            for request in batch:
                batch_entity_rows.extend(request['entity_rows'])
                batch_features.update(request['features'])
            
            # Get features for entire batch
            batch_df = self.get_online_features(
                entity_rows=batch_entity_rows,
                features=list(batch_features)
            )
            
            results.append(batch_df)
            
            # Add small delay to prevent overwhelming the store
            await asyncio.sleep(0.01)
        
        return results

# Example usage for ML model serving
class MLModelWithFeatures:
    """
    ML model integrated with Feast feature serving
    """
    
    def __init__(self, model_path: str, feature_service: ProductionFeatureService):
        # Load your trained model (example with joblib)
        import joblib
        self.model = joblib.load(model_path)
        self.feature_service = feature_service
        
        # Define required features for the model
        self.required_features = [
            "user_features:age",
            "user_features:income", 
            "user_features:total_purchases",
            "product_features:price",
            "product_features:rating",
            "user_product_features:recommendation_score"
        ]
    
    def predict(self, user_id: str, product_id: str, 
                request_data: Dict[str, Any] = None) -> float:
        """
        Make prediction using fresh features from Feast
        """
        # Prepare entity row
        entity_row = {
            "user_id": user_id,
            "product_id": product_id
        }
        
        # Add request data for on-demand features
        if request_data:
            entity_row.update(request_data)
        
        # Get features
        features_df = self.feature_service.get_online_features(
            entity_rows=[entity_row],
            features=self.required_features
        )
        
        # Prepare features for model
        feature_vector = features_df[self.required_features].values[0]
        
        # Make prediction
        prediction = self.model.predict([feature_vector])[0]
        
        return prediction
    
    def batch_predict(self, requests: List[Dict[str, Any]]) -> List[float]:
        """
        Batch prediction with efficient feature retrieval
        """
        # Prepare entity rows
        entity_rows = []
        for req in requests:
            entity_row = {
                "user_id": req["user_id"],
                "product_id": req["product_id"]
            }
            if "request_data" in req:
                entity_row.update(req["request_data"])
            entity_rows.append(entity_row)
        
        # Get all features at once
        features_df = self.feature_service.get_online_features(
            entity_rows=entity_rows,
            features=self.required_features
        )
        
        # Make batch predictions
        feature_matrix = features_df[self.required_features].values
        predictions = self.model.predict(feature_matrix)
        
        return predictions.tolist()

# Feature monitoring and validation
class FeatureMonitor:
    """
    Monitor feature quality and detect drift
    """
    
    def __init__(self, feature_service: ProductionFeatureService):
        self.feature_service = feature_service
        self.logger = logging.getLogger(__name__)
    
    def validate_features(self, features_df: pd.DataFrame) -> Dict[str, Any]:
        """
